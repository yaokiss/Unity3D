## 多线程概念

当一个程序开始运行时，它就是一个进程，进程包括运行中的程序和程序所使用到的内存和系统资源。而一个进程又是由多个线程所组成的

线程是程序中的一个执行流，每个线程都有自己的专有寄存器(栈指针、程序计数器等)，但代码区是共享的，即不同的线程可以执行同样的函数。

多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务

多线程的好处：可以提高CPU的利用率。在多线程程序中，一个线程必须等待的时候，CPU可以运行其它的线程而不是等待，这样就大大提高了程序的效率


多线程的不利方面：线程也是程序，所以线程需要占用内存，线程越多占用内存也越多； 多线程需要协调和管理，所以需要CPU时间跟踪线程； 线程之间对共享资源的访问会相互影响，必须解决竞用共享资源的问题；线程太多会导致控制太复杂，最终可能造成很多Bug；


多线程的介绍：C#通过多线程支持并行执行的代码。一个线程是一个独立执行的路径，可以同时与其他线程一起运行。一个C#客户端程序(Console,WPF,Winows Forms)开始于一个单独的线程，该线程由CLR和操作系统自动地创建，我们称它为主线程，而且可以通过创建附加的线程来实现多线程。


操作系统以“时间片轮转”的方式实现多个程序运行，以进程的方式运行应用程序，进程不但包括应用程序的执行流，也包括运行程序的内存、寄存器等资源，
线程非常类似于进程，它相当于在一个进程中创建若干条并行的进程，操作系统将自动以“时间片轮转”的方式交替执行线程中的指令，同一个进程中的所有线程
共享进程的资源，所以他们之间的切换比进程的切换快的多，因此线程可以看作轻量级进程，操作系统中有专门的调度程序管理线程，根据事先设计好的算法轮流执行每个线程
，线程是操作系统进行CPU调度的基本单位，线程的调度是由操作系统自动完成的，程序员只需要编写好线程即可。


## 创建线程

```
using System;
using System.Threading;
class Program
{
     static void Main(string[] args)
     {
           Thread thread = new Thread(ThreadA);//创建一个线程
           thread.Start();//开始一个线程

           for (int i = 0; i < 1000; i++)//主线程执行循环
           {
                Console.Write("A");
           }

                Console.ReadLine();
           }
           static void ThreadA()
           {
               for (int i = 0; i < 1000; i++)
               {
                   Console.Write("B");
               }
            }
}
```



## 线程的使用

### Thread类

每开启一个引用程序，系统就会创建一个与该程序相关的进程，紧接着就会创建一个主线程，然后主函数中的代码开始执行。我们可以在一个应用程序中创建任意多个线程，每个线程完成一项任务。

在C#中，线程由System.Threading命名空间的Thread类实现。
```
Thread workthread = new Thread(entrypoint);
```

每个线程都需要一个入口函数。因为线程从入口函数中的代码开始执行，所以我么需要事先编写好一个入口函数，然后把它传递给线程，可以通过委托机制完成，
在C#中，与入口函数相关的委托是ThreadStart。
```
public delegate void ThreadStart();
```
传递给线程入口的函数必须是没有参数和返回值的函数，


创建一个线程一般要经理三个步骤：
```
//编写入口函数
private void EntryPointMethod()
{
}

//创建入口委托
ThreadStart entryPoint = new Thread(EntryPointMethod);
//创建线程
Thread workThread = new Thread(entryPoint);
```

Thread类提供了丰富的属性和方法，可以非常方便的控制线程。

![](https://nts.newbieol.com/static/k25/03_%E5%BC%95%E6%93%8E%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/Socket%E9%80%9A%E4%BF%A1/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5/images/Image1.png)


### 线程的优先级

计算机中经常会多个任务同时运行，其中总有一些看起来更紧急，更需要优先完成。比如我们现在有两个任务，一个任务是下载一部电影，另一个任务是检测用户的输入。显然及时响应用户操作应具有更高的优先级，因为我们不能让用户等得太久。

线程的优先级可以通过Thread类Priority属性设置，Priority属性是一个ThreadPriority型枚举，列举了5个优先等级

![](https://nts.newbieol.com/static/k25/03_%E5%BC%95%E6%93%8E%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/Socket%E9%80%9A%E4%BF%A1/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5/images/Image2.png)

普通线程的优先级默认认为Normal；如果想有更高的优先级，可设置为AboveNormal或Highest;如果想有较低的优先级，可设置为BelowNormal或Lowest.

```
class Program
{
    static void Main(string[] args)
    {

        //1.线程A
        ThreadStart threadPoint = new ThreadStart(TestA);
        Thread threadA = new Thread(threadPoint);


         //线程B
         Thread threadB = new Thread(delegate ()
         {
              for (int i = 0; i < 500000000; i++)
              {
                  if (i % 100000 == 0)
                  {
                      Console.Write('B');
                  }
              }

          });

            //3.线程的优先级
            //  threadA.Priority = ThreadPriority.Highest;
            //  threadB.Priority = ThreadPriority.Lowest;

            //启动线程
            threadA.Start();
            threadB.Start();

            //2.工作线程和主线程的并发运行
            for (int i = 0; i <= 500000000; i++)
            {
                if (i % 100000 == 0)
                {
                    Console.Write('M');
                }

            }
            Console.ReadKey();

        }
        static void TestA()
        {
            for (int i = 0; i < 500000000; i++)
            {
                if (i % 100000 == 0)
                {
                    Console.Write('A');
                }
            }
        }
}
```


### 线程的插入



### 线程的状态

在线程的声明周期中，线程的状态并非是一成不变的，，可能经历多重状态，现成的状态由Thread类的ThreadState属性来表示

![](https://nts.newbieol.com/static/k25/03_%E5%BC%95%E6%93%8E%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/Socket%E9%80%9A%E4%BF%A1/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5/images/Image3.png)

一旦线程被创建，他就处于某个状态中，而且可以同时处于多个状态中，比如线程在WaitSleepJoin状态时收到Aborted()请求时。将同时处于WaitSleepJoin状态
和AbortRequested状态

线程状态之间转换规律演示：

![](https://nts.newbieol.com/static/k25/03_%E5%BC%95%E6%93%8E%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/Socket%E9%80%9A%E4%BF%A1/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5/images/Image4.png)

当一个线程被创建后。他就处于Unstarted状态，知道调用了Start（）方法为止，但处于Running状态的线程也不是一定正在被CPU执行可能该线程的时间片刚刚用完
，CPU正在处理其他线程，过一点时间后才会处理它。

有三种方法时线程由Running状态为WaitSleepJoin状态。第一种情况是为了保持线程间的同步而使之处于等待状态，当到达指定的睡眠时间后，线程将会回到Running状态，第三种情况是调用Join()方法，比如在线程A的代码中调用了线程B Join()方法。线程A将处于WiatSleepJoin状态，直到线程B结束。开始继续执行A时为止






























































